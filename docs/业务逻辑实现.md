# 核心业务逻辑实现文档

## 文档信息

- **项目名称**: Lumina记账App
- **版本**: v1.0
- **创建日期**: 2026-01-24

---

## 目录

1. [交易类型处理逻辑](#1-交易类型处理逻辑)
2. [转账逻辑](#2-转账逻辑transfer)
3. [退款逻辑](#3-退款逻辑refund)
4. [信用卡管理逻辑](#4-信用卡管理逻辑)
5. [报销与应收管理](#5-报销与应收管理)
6. [预算计算逻辑](#6-预算计算逻辑)
7. [分期付款逻辑](#7-分期付款逻辑)
8. [拆单与AA制](#8-拆单与aa制)
9. [数据统计计算](#9-数据统计计算)
10. [边界条件处理](#10-边界条件处理)

---

## 1. 交易类型处理逻辑

### 1.1 四种交易类型

记账系统核心有**四种交易类型**，每种类型的账户余额处理逻辑不同：

```swift
enum TransactionType: String, Codable {
    case expense    // 支出：减少资产
    case income     // 收入：增加资产
    case transfer   // 转账：资产间转移，不影响总资产
    case adjustment // 调整：直接设置余额，用于对账
}
```

### 1.2 交易处理核心类

```swift
import Foundation
import SwiftData

@MainActor
class TransactionService {
    private let modelContext: ModelContext
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    /// 创建交易（核心方法）
    func createTransaction(
        ledger: Ledger,
        type: TransactionType,
        amount: Decimal,
        date: Date,
        fromAccount: Account? = nil,
        toAccount: Account? = nil,
        category: Category? = nil,
        note: String? = nil,
        payee: String? = nil,
        tags: [Tag] = []
    ) throws -> Transaction {
        // 1. 数据验证
        try validateTransaction(
            type: type,
            amount: amount,
            fromAccount: fromAccount,
            toAccount: toAccount,
            category: category
        )
        
        // 2. 创建交易实体
        let transaction = Transaction(
            ledger: ledger,
            amount: amount,
            date: date,
            type: type,
            fromAccount: fromAccount,
            toAccount: toAccount,
            category: category,
            note: note,
            payee: payee
        )
        transaction.tags = tags
        
        // 3. 插入数据库
        modelContext.insert(transaction)
        
        // 4. 更新账户余额
        try updateAccountBalances(for: transaction)
        
        // 5. 保存上下文
        try modelContext.save()
        
        // 6. 触发通知（用于Widget更新等）
        NotificationCenter.default.post(
            name: .transactionCreated,
            object: transaction
        )
        
        return transaction
    }
    
    /// 更新账户余额
    private func updateAccountBalances(for transaction: Transaction) throws {
        switch transaction.type {
        case .expense:
            // 支出：扣减来源账户
            guard let fromAccount = transaction.fromAccount else {
                throw TransactionError.missingFromAccount
            }
            fromAccount.balance -= transaction.amount
            
        case .income:
            // 收入：增加目标账户
            guard let toAccount = transaction.toAccount else {
                throw TransactionError.missingToAccount
            }
            toAccount.balance += transaction.amount
            
        case .transfer:
            // 转账：扣减来源账户，增加目标账户
            guard let fromAccount = transaction.fromAccount,
                  let toAccount = transaction.toAccount else {
                throw TransactionError.invalidTransfer
            }
            fromAccount.balance -= transaction.amount
            toAccount.balance += transaction.amount
            
        case .adjustment:
            // 调整：直接设置目标账户余额
            guard let toAccount = transaction.toAccount else {
                throw TransactionError.missingToAccount
            }
            toAccount.balance = transaction.amount
        }
    }
    
    /// 数据验证
    private func validateTransaction(
        type: TransactionType,
        amount: Decimal,
        fromAccount: Account?,
        toAccount: Account?,
        category: Category?
    ) throws {
        // 金额必须大于0（退款例外，在退款专用方法中处理）
        guard amount > 0 else {
            throw TransactionError.invalidAmount
        }
        
        switch type {
        case .expense:
            guard fromAccount != nil else {
                throw TransactionError.missingFromAccount
            }
            guard category != nil else {
                throw TransactionError.missingCategory
            }
            
        case .income:
            guard toAccount != nil else {
                throw TransactionError.missingToAccount
            }
            guard category != nil else {
                throw TransactionError.missingCategory
            }
            
        case .transfer:
            guard fromAccount != nil, toAccount != nil else {
                throw TransactionError.invalidTransfer
            }
            guard fromAccount != toAccount else {
                throw TransactionError.sameAccountTransfer
            }
            
        case .adjustment:
            guard toAccount != nil else {
                throw TransactionError.missingToAccount
            }
        }
    }
}

// MARK: - 错误类型

enum TransactionError: LocalizedError {
    case invalidAmount
    case missingFromAccount
    case missingToAccount
    case missingCategory
    case invalidTransfer
    case sameAccountTransfer
    case insufficientBalance
    
    var errorDescription: String? {
        switch self {
        case .invalidAmount: return "金额必须大于0"
        case .missingFromAccount: return "请选择支出账户"
        case .missingToAccount: return "请选择收入账户"
        case .missingCategory: return "请选择分类"
        case .invalidTransfer: return "转账需要指定来源和目标账户"
        case .sameAccountTransfer: return "不能在同一账户间转账"
        case .insufficientBalance: return "账户余额不足"
        }
    }
}
```

---

## 2. 转账逻辑 (Transfer)

### 2.1 核心原则

**转账的本质是资产在不同账户间的流动，不影响净资产，不计入收支报表。**

### 2.2 转账实现

```swift
extension TransactionService {
    /// 创建转账交易
    func createTransfer(
        ledger: Ledger,
        from fromAccount: Account,
        to toAccount: Account,
        amount: Decimal,
        date: Date = Date(),
        fee: Decimal = 0,
        note: String? = nil
    ) throws -> (transfer: Transaction, feeTransaction: Transaction?) {
        // 1. 检查余额（对于非信用卡账户）
        if fromAccount.type != .creditCard {
            guard fromAccount.balance >= (amount + fee) else {
                throw TransactionError.insufficientBalance
            }
        }
        
        // 2. 创建转账交易
        let transfer = try createTransaction(
            ledger: ledger,
            type: .transfer,
            amount: amount,
            date: date,
            fromAccount: fromAccount,
            toAccount: toAccount,
            note: note
        )
        
        // 3. 处理手续费（如果有）
        var feeTransaction: Transaction? = nil
        if fee > 0 {
            // 手续费作为支出处理
            let feeCategory = try getOrCreateFeeCategory(ledger: ledger)
            feeTransaction = try createTransaction(
                ledger: ledger,
                type: .expense,
                amount: fee,
                date: date,
                fromAccount: fromAccount,
                category: feeCategory,
                note: "转账手续费"
            )
        }
        
        return (transfer, feeTransaction)
    }
    
    /// 信用卡还款（特殊的转账）
    func creditCardPayment(
        ledger: Ledger,
        from bankAccount: Account,
        to creditCard: Account,
        amount: Decimal,
        date: Date = Date()
    ) throws -> Transaction {
        guard creditCard.type == .creditCard else {
            throw TransactionError.invalidTransfer
        }
        
        // 信用卡余额为负数，还款后变得"更正"（数值上增加）
        let (transfer, _) = try createTransfer(
            ledger: ledger,
            from: bankAccount,
            to: creditCard,
            amount: amount,
            date: date,
            note: "信用卡还款"
        )
        
        return transfer
    }
    
    private func getOrCreateFeeCategory(ledger: Ledger) throws -> Category {
        // 查找或创建"手续费"分类
        let descriptor = FetchDescriptor<Category>(
            predicate: #Predicate { $0.ledger == ledger && $0.name == "手续费" }
        )
        
        if let existing = try modelContext.fetch(descriptor).first {
            return existing
        }
        
        let feeCategory = Category(
            ledger: ledger,
            name: "手续费",
            type: .expense,
            iconName: "dollarsign.circle"
        )
        modelContext.insert(feeCategory)
        return feeCategory
    }
}
```

### 2.3 转账示例场景

#### 场景1: ATM取款

```swift
// 从银行卡取现金
let (transfer, _) = try transactionService.createTransfer(
    ledger: currentLedger,
    from: bankAccount,     // 工行储蓄卡
    to: cashAccount,       // 现金
    amount: 500,
    note: "ATM取款"
)

// 结果：
// - 银行卡余额 -500
// - 现金余额 +500
// - 净资产不变
// - 不出现在支出报表中
```

#### 场景2: 微信充值

```swift
let (transfer, _) = try transactionService.createTransfer(
    ledger: currentLedger,
    from: bankAccount,     // 银行卡
    to: wechatAccount,     // 微信零钱
    amount: 1000,
    note: "微信充值"
)
```

#### 场景3: 信用卡还款

```swift
let payment = try transactionService.creditCardPayment(
    ledger: currentLedger,
    from: bankAccount,        // 储蓄卡
    to: creditCardAccount,    // 信用卡（余额为-3200）
    amount: 3200
)

// 结果：
// - 储蓄卡余额 -3200
// - 信用卡余额从-3200变为0
// - 不计入支出（避免"还款即支出"的错误理解）
```

---

## 3. 退款逻辑 (Refund)

### 3.1 核心原则

**退款不是"收入"，而是对原支出的冲销，应该减少对应分类的支出金额。**

### 3.2 退款实现方式

#### 方案A: 负数支出（推荐）

```swift
extension TransactionService {
    /// 创建退款交易（作为负数支出）
    func createRefund(
        ledger: Ledger,
        toAccount: Account,
        originalCategory: Category,
        amount: Decimal,
        date: Date = Date(),
        originalTransaction: Transaction? = nil,
        note: String? = nil
    ) throws -> Transaction {
        // 创建负数金额的支出交易
        let refundNote = originalTransaction != nil 
            ? "退款：\(originalTransaction!.note ?? "")"
            : note ?? "退款"
        
        let refund = Transaction(
            ledger: ledger,
            amount: -amount,  // 注意：负数！
            date: date,
            type: .expense,   // 类型仍然是支出
            toAccount: toAccount,  // 退款到哪个账户
            category: originalCategory,  // 原支出分类
            note: refundNote
        )
        
        modelContext.insert(refund)
        
        // 更新余额：负数支出实际上增加账户余额
        toAccount.balance += amount
        
        try modelContext.save()
        
        return refund
    }
    
    /// 快捷方法：直接对某笔交易退款
    func refundTransaction(
        _ originalTransaction: Transaction,
        refundAmount: Decimal? = nil
    ) throws -> Transaction {
        let amount = refundAmount ?? originalTransaction.amount
        
        guard originalTransaction.type == .expense else {
            throw TransactionError.invalidRefund
        }
        
        return try createRefund(
            ledger: originalTransaction.ledger!,
            toAccount: originalTransaction.fromAccount!,
            originalCategory: originalTransaction.category!,
            amount: amount,
            originalTransaction: originalTransaction
        )
    }
}

enum TransactionError: LocalizedError {
    // ... 其他错误
    case invalidRefund
    
    var errorDescription: String? {
        switch self {
        case .invalidRefund: return "只能对支出交易进行退款"
        // ...
        }
    }
}
```

### 3.3 退款的报表影响

```swift
extension Category {
    /// 计算某月的净支出（已自动处理退款）
    func netExpenseForMonth(_ date: Date) -> Decimal {
        let calendar = Calendar.current
        let transactions = self.allTransactions.filter { transaction in
            transaction.type == .expense &&
            calendar.isDate(transaction.date, equalTo: date, toGranularity: .month)
        }
        
        // 直接累加，负数支出会自动抵扣
        // 例如：100 - 50（退款） + 30 = 80
        return transactions.reduce(0) { $0 + $1.amount }
    }
}
```

### 3.4 退款示例场景

#### 场景：购物退货

```swift
// 原交易：买衣服花了299元
let originalPurchase = try transactionService.createTransaction(
    ledger: currentLedger,
    type: .expense,
    amount: 299,
    date: Date(),
    fromAccount: creditCard,
    category: clothingCategory,
    note: "买衣服"
)
// 信用卡余额：-299

// 7天后退货
let refund = try transactionService.refundTransaction(originalPurchase)
// 信用卡余额：0
// "服饰"分类本月支出：299 + (-299) = 0
// 收入不受影响，保持正确
```

---

## 4. 信用卡管理逻辑

### 4.1 信用卡特性

信用卡不同于普通账户，有以下特点：
1. **余额为负数**：表示欠款
2. **有信用额度**：可用额度 = 总额度 + 当前余额（余额为负）
3. **账单日和还款日**：需要提醒用户
4. **账单周期**：流水按账单周期分组

### 4.2 信用卡账户模型

```swift
extension Account {
    /// 信用卡专用：可用额度
    var availableCreditLimit: Decimal {
        guard type == .creditCard, let limit = creditLimit else {
            return 0
        }
        // 余额为负数，所以是加法
        // 例如：额度10000，已用3000（余额-3000），可用=10000+(-3000)=7000
        return limit + balance
    }
    
    /// 信用卡专用：已用额度
    var usedCreditLimit: Decimal {
        guard type == .creditCard else { return 0 }
        return abs(balance)
    }
    
    /// 信用卡专用：额度使用率
    var creditUtilizationRate: Double {
        guard type == .creditCard, let limit = creditLimit, limit > 0 else {
            return 0
        }
        return Double(truncating: (usedCreditLimit / limit) as NSNumber)
    }
    
    /// 验证信用卡是否超限
    func validateCreditLimit() -> Bool {
        guard type == .creditCard, let limit = creditLimit else {
            return true
        }
        return usedCreditLimit <= limit
    }
}
```

### 4.3 账单周期计算

```swift
import Foundation

struct BillingCycle {
    let startDate: Date
    let endDate: Date
    let statementDate: Date
    let dueDate: Date
}

extension Account {
    /// 计算指定日期所在的账单周期
    func billingCycle(for date: Date = Date()) -> BillingCycle? {
        guard type == .creditCard,
              let statementDay = statementDay,
              let dueDay = dueDay else {
            return nil
        }
        
        let calendar = Calendar.current
        
        // 1. 确定账单日
        let currentMonth = calendar.component(.month, from: date)
        let currentYear = calendar.component(.year, from: date)
        
        var statementDate = calendar.date(
            from: DateComponents(year: currentYear, month: currentMonth, day: statementDay)
        )!
        
        // 如果当前日期在账单日之后，账单日应该是本月，否则是上月
        if date < statementDate {
            statementDate = calendar.date(byAdding: .month, value: -1, to: statementDate)!
        }
        
        // 2. 账单周期开始日期 = 上期账单日 + 1天
        let startDate = calendar.date(byAdding: .day, value: 1, to: statementDate)!
        
        // 3. 账单周期结束日期 = 下期账单日
        let endDate = calendar.date(byAdding: .month, value: 1, to: statementDate)!
        
        // 4. 还款日
        var dueDate = calendar.date(
            from: DateComponents(
                year: calendar.component(.year, from: endDate),
                month: calendar.component(.month, from: endDate),
                day: dueDay
            )
        )!
        
        // 还款日如果在账单日之前，说明是下个月
        if dueDate <= endDate {
            dueDate = calendar.date(byAdding: .month, value: 1, to: dueDate)!
        }
        
        return BillingCycle(
            startDate: startDate,
            endDate: endDate,
            statementDate: endDate,
            dueDate: dueDate
        )
    }
    
    /// 当前账单周期的消费金额
    func currentBillingAmount() -> Decimal {
        guard let cycle = billingCycle() else { return 0 }
        
        // 查询该账单周期内的所有支出
        let transactions = outgoingTransactions.filter { transaction in
            transaction.type == .expense &&
            transaction.date >= cycle.startDate &&
            transaction.date <= cycle.endDate
        }
        
        return transactions.reduce(0) { $0 + $1.amount }
    }
    
    /// 距离下次账单日的天数
    var daysUntilNextStatement: Int? {
        guard let cycle = billingCycle() else { return nil }
        let calendar = Calendar.current
        return calendar.dateComponents([.day], from: Date(), to: cycle.statementDate).day
    }
    
    /// 距离还款日的天数
    var daysUntilDueDate: Int? {
        guard let cycle = billingCycle() else { return nil }
        let calendar = Calendar.current
        return calendar.dateComponents([.day], from: Date(), to: cycle.dueDate).day
    }
}
```

### 4.4 信用卡使用场景

#### 场景1: 信用卡消费

```swift
// 用信用卡吃饭
let transaction = try transactionService.createTransaction(
    ledger: currentLedger,
    type: .expense,
    amount: 128.5,
    date: Date(),
    fromAccount: creditCard,  // 余额：-3200 -> -3328.5
    category: diningCategory,
    note: "午餐"
)

// 检查是否超限
if !creditCard.validateCreditLimit() {
    print("警告：已超信用额度！")
}
```

#### 场景2: 账单提醒

```swift
class CreditCardReminderService {
    func checkAndSendReminders() {
        let creditCards = fetchAllCreditCards()
        
        for card in creditCards {
            // 账单日前3天提醒
            if let days = card.daysUntilNextStatement, days <= 3 && days > 0 {
                sendNotification(
                    title: "\(card.name)账单日提醒",
                    body: "还有\(days)天出账单，当前待还款\(card.usedCreditLimit.formatted())"
                )
            }
            
            // 还款日前1天提醒
            if let days = card.daysUntilDueDate, days == 1 {
                sendNotification(
                    title: "\(card.name)还款提醒",
                    body: "明天是最后还款日，请及时还款\(card.usedCreditLimit.formatted())"
                )
            }
        }
    }
}
```

---

## 5. 报销与应收管理

### 5.1 核心原则

**报销/垫付的支出不应计入个人消费，而应转为"应收账款"。**

### 5.2 应收账户逻辑

```swift
extension TransactionService {
    /// 创建报销类交易
    func createReimbursableExpense(
        ledger: Ledger,
        amount: Decimal,
        date: Date = Date(),
        fromAccount: Account,
        category: Category,
        reimbursementSource: String,  // 例如："公司"、"朋友张三"
        note: String? = nil
    ) throws -> (expense: Transaction, receivable: Transaction) {
        // 1. 创建支出交易（标记为报销类）
        let expense = try createTransaction(
            ledger: ledger,
            type: .expense,
            amount: amount,
            date: date,
            fromAccount: fromAccount,
            category: category,
            note: note
        )
        
        // 2. 获取或创建应收账户
        let receivableAccount = try getOrCreateReceivableAccount(
            ledger: ledger,
            name: reimbursementSource
        )
        
        // 3. 创建转账到应收账户（实际上是记录债权）
        let (receivable, _) = try createTransfer(
            ledger: ledger,
            from: fromAccount,
            to: receivableAccount,
            amount: amount,
            date: date,
            note: "待\(reimbursementSource)报销"
        )
        
        // 净效果：
        // - fromAccount余额 -amount（实际支出）
        // - receivableAccount余额 +amount（债权增加）
        // - 总资产不变（-amount + amount = 0）
        // - 不计入个人消费报表（因为receivableAccount.excludeFromTotal = true）
        
        return (expense, receivable)
    }
    
    /// 收到报销款
    func receiveReimbursement(
        ledger: Ledger,
        amount: Decimal,
        date: Date = Date(),
        fromReceivableAccount: Account,
        toBankAccount: Account,
        note: String? = nil
    ) throws -> Transaction {
        guard fromReceivableAccount.type == .receivable else {
            throw TransactionError.invalidReceivable
        }
        
        // 从应收账户转到银行账户
        let (transfer, _) = try createTransfer(
            ledger: ledger,
            from: fromReceivableAccount,
            to: toBankAccount,
            amount: amount,
            date: date,
            note: note ?? "收到报销款"
        )
        
        return transfer
    }
    
    private func getOrCreateReceivableAccount(
        ledger: Ledger,
        name: String
    ) throws -> Account {
        let descriptor = FetchDescriptor<Account>(
            predicate: #Predicate { 
                $0.ledger == ledger && $0.name == name && $0.type == .receivable
            }
        )
        
        if let existing = try modelContext.fetch(descriptor).first {
            return existing
        }
        
        let account = Account(
            ledger: ledger,
            name: name,
            type: .receivable,
            iconName: "arrow.up.circle"
        )
        account.excludeFromTotal = false  // 应收也是资产
        modelContext.insert(account)
        return account
    }
}
```

### 5.3 报销示例场景

#### 场景：帮公司买机票

```swift
// 1. 刷信用卡买机票 ¥1500
let (expense, receivable) = try transactionService.createReimbursableExpense(
    ledger: currentLedger,
    amount: 1500,
    fromAccount: creditCard,
    category: businessTravelCategory,
    reimbursementSource: "公司",
    note: "北京出差机票"
)

// 余额状态：
// - 信用卡：-1500（欠款增加）
// - 应收-公司：+1500（债权）
// - 净资产：0（无变化）
// - "商旅"分类支出：1500（但不计入个人消费统计）

// 2. 一周后收到公司报销
let reimbursement = try transactionService.receiveReimbursement(
    ledger: currentLedger,
    amount: 1500,
    fromReceivableAccount: companyReceivable,
    toBankAccount: bankAccount,
    note: "出差报销到账"
)

// 余额状态：
// - 应收-公司：0（债权清零）
// - 银行卡：+1500
// - 用这笔钱还信用卡
let payment = try transactionService.creditCardPayment(
    ledger: currentLedger,
    from: bankAccount,
    to: creditCard,
    amount: 1500
)

// 最终：所有余额恢复原状，1500元完全不影响个人财务
```

---

## 6. 预算计算逻辑

### 6.1 预算计算服务

```swift
@MainActor
class BudgetCalculationService {
    private let modelContext: ModelContext
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    /// 计算预算使用情况
    func calculateBudgetUsage(for budget: Budget, at date: Date = Date()) -> BudgetUsage {
        guard let category = budget.category else {
            return BudgetUsage(budget: budget, used: 0, remaining: budget.effectiveBudget)
        }
        
        // 1. 确定统计周期
        let (startDate, endDate) = budget.currentPeriodRange(at: date)
        
        // 2. 查询该分类的支出（包括子分类）
        let transactions = category.allTransactions.filter { transaction in
            transaction.type == .expense &&
            transaction.date >= startDate &&
            transaction.date <= endDate
        }
        
        // 3. 累计支出（负数退款会自动抵扣）
        let usedAmount = transactions.reduce(0) { $0 + $1.amount }
        
        // 4. 计算剩余
        let remainingAmount = budget.effectiveBudget - usedAmount
        
        return BudgetUsage(
            budget: budget,
            used: usedAmount,
            remaining: remainingAmount,
            startDate: startDate,
            endDate: endDate
        )
    }
    
    /// 检查所有预算状态，发送提醒
    func checkBudgetsAndNotify(ledger: Ledger) {
        let budgets = ledger.budgets.filter { $0.isEnabled }
        
        for budget in budgets {
            let usage = calculateBudgetUsage(for: budget)
            
            // 90%预警
            if usage.percentage >= 0.9 && usage.percentage < 1.0 {
                sendBudgetWarning(budget: budget, usage: usage, level: .warning)
            }
            
            // 100%超支
            if usage.percentage >= 1.0 {
                sendBudgetWarning(budget: budget, usage: usage, level: .overbudget)
            }
        }
    }
    
    private func sendBudgetWarning(budget: Budget, usage: BudgetUsage, level: BudgetWarningLevel) {
        let title: String
        let body: String
        
        switch level {
        case .warning:
            title = "预算预警"
            body = "\(budget.category?.name ?? "")预算已使用\(Int(usage.percentage * 100))%，剩余\(usage.remaining.formatted())"
        case .overbudget:
            title = "预算超支"
            body = "\(budget.category?.name ?? "")预算已超支\(abs(usage.remaining).formatted())"
        }
        
        NotificationService.shared.send(title: title, body: body)
    }
}

struct BudgetUsage {
    let budget: Budget
    let used: Decimal
    let remaining: Decimal
    var startDate: Date = Date()
    var endDate: Date = Date()
    
    var percentage: Double {
        guard budget.effectiveBudget > 0 else { return 0 }
        return Double(truncating: (used / budget.effectiveBudget) as NSNumber)
    }
    
    var status: BudgetStatus {
        if percentage >= 1.0 {
            return .overBudget
        } else if percentage >= 0.9 {
            return .nearLimit
        } else if percentage >= 0.8 {
            return .warning
        } else {
            return .safe
        }
    }
}

enum BudgetWarningLevel {
    case warning
    case overbudget
}
```

### 6.2 预算周期范围计算

```swift
extension Budget {
    /// 计算当前周期的起止日期
    func currentPeriodRange(at date: Date = Date()) -> (start: Date, end: Date) {
        let calendar = Calendar.current
        
        switch period {
        case .daily:
            let start = calendar.startOfDay(for: date)
            let end = calendar.date(byAdding: .day, value: 1, to: start)!
            return (start, end)
            
        case .weekly:
            let start = calendar.date(from: calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: date))!
            let end = calendar.date(byAdding: .weekOfYear, value: 1, to: start)!
            return (start, end)
            
        case .monthly:
            let start = calendar.date(from: calendar.dateComponents([.year, .month], from: date))!
            let end = calendar.date(byAdding: .month, value: 1, to: start)!
            return (start, end)
            
        case .quarterly:
            let month = calendar.component(.month, from: date)
            let quarterStartMonth = ((month - 1) / 3) * 3 + 1
            let start = calendar.date(from: DateComponents(
                year: calendar.component(.year, from: date),
                month: quarterStartMonth,
                day: 1
            ))!
            let end = calendar.date(byAdding: .month, value: 3, to: start)!
            return (start, end)
            
        case .yearly:
            let start = calendar.date(from: calendar.dateComponents([.year], from: date))!
            let end = calendar.date(byAdding: .year, value: 1, to: start)!
            return (start, end)
            
        case .custom:
            return (startDate, endDate ?? Date())
        }
    }
}
```

### 6.3 预算结转逻辑

```swift
extension BudgetCalculationService {
    /// 月末处理：结转预算
    func rolloverBudgets(ledger: Ledger) {
        let budgets = ledger.budgets.filter { $0.isEnabled && $0.enableRollover }
        
        for budget in budgets {
            let usage = calculateBudgetUsage(for: budget)
            
            // 将剩余金额结转到下月
            budget.rolloverAmount = max(usage.remaining, 0)  // 只结转正数
            
            // 更新周期开始日期
            let (_, endDate) = budget.currentPeriodRange()
            budget.startDate = endDate
        }
        
        try? modelContext.save()
    }
}
```

---

## 7. 分期付款逻辑

### 7.1 分期记录模型

```swift
import Foundation
import SwiftData

@Model
final class Installment {
    @Attribute(.unique) var id: UUID
    
    /// 总金额
    var totalAmount: Decimal
    
    /// 期数
    var totalPeriods: Int
    
    /// 每期金额
    var periodAmount: Decimal
    
    /// 开始日期
    var startDate: Date
    
    /// 分期间隔（天）
    var intervalDays: Int
    
    /// 已完成期数
    var completedPeriods: Int
    
    /// 关联账户
    var account: Account?
    
    /// 关联分类
    var category: Category?
    
    /// 描述
    var note: String?
    
    /// 生成的交易
    @Relationship(deleteRule: .nullify)
    var generatedTransactions: [Transaction]
    
    init(
        totalAmount: Decimal,
        periods: Int,
        startDate: Date,
        intervalDays: Int = 30,
        account: Account,
        category: Category,
        note: String? = nil
    ) {
        self.id = UUID()
        self.totalAmount = totalAmount
        self.totalPeriods = periods
        self.periodAmount = (totalAmount / Decimal(periods)).rounded(2)
        self.startDate = startDate
        self.intervalDays = intervalDays
        self.completedPeriods = 0
        self.account = account
        self.category = category
        self.note = note
        self.generatedTransactions = []
    }
}

extension Decimal {
    func rounded(_ scale: Int) -> Decimal {
        var result = self
        var roundedValue = self
        NSDecimalRound(&result, &roundedValue, scale, .bankers)
        return result
    }
}
```

### 7.2 分期服务

```swift
@MainActor
class InstallmentService {
    private let modelContext: ModelContext
    private let transactionService: TransactionService
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
        self.transactionService = TransactionService(modelContext: modelContext)
    }
    
    /// 创建分期计划
    func createInstallmentPlan(
        ledger: Ledger,
        totalAmount: Decimal,
        periods: Int,
        startDate: Date,
        account: Account,
        category: Category,
        note: String? = nil
    ) throws -> Installment {
        let installment = Installment(
            totalAmount: totalAmount,
            periods: periods,
            startDate: startDate,
            account: account,
            category: category,
            note: note
        )
        
        modelContext.insert(installment)
        
        // 立即生成第一期
        try generateNextPeriod(installment: installment, ledger: ledger)
        
        try modelContext.save()
        
        return installment
    }
    
    /// 生成下一期交易
    func generateNextPeriod(installment: Installment, ledger: Ledger) throws {
        guard installment.completedPeriods < installment.totalPeriods else {
            return  // 已完成所有期数
        }
        
        let periodNumber = installment.completedPeriods + 1
        let calendar = Calendar.current
        
        // 计算本期日期
        let periodDate = calendar.date(
            byAdding: .day,
            value: installment.intervalDays * installment.completedPeriods,
            to: installment.startDate
        )!
        
        // 最后一期可能需要调整金额（处理除不尽的情况）
        let amount: Decimal
        if periodNumber == installment.totalPeriods {
            let paidSoFar = installment.periodAmount * Decimal(installment.completedPeriods)
            amount = installment.totalAmount - paidSoFar
        } else {
            amount = installment.periodAmount
        }
        
        // 创建交易
        let transaction = try transactionService.createTransaction(
            ledger: ledger,
            type: .expense,
            amount: amount,
            date: periodDate,
            fromAccount: installment.account,
            category: installment.category,
            note: "\(installment.note ?? "分期付款") (\(periodNumber)/\(installment.totalPeriods))"
        )
        
        installment.generatedTransactions.append(transaction)
        installment.completedPeriods += 1
        
        try modelContext.save()
    }
    
    /// 检查并生成到期的分期
    func processOverdueInstallments() {
        let descriptor = FetchDescriptor<Installment>(
            predicate: #Predicate { $0.completedPeriods < $0.totalPeriods }
        )
        
        guard let installments = try? modelContext.fetch(descriptor) else { return }
        
        let calendar = Calendar.current
        let today = Date()
        
        for installment in installments {
            let nextPeriodNumber = installment.completedPeriods + 1
            let nextPeriodDate = calendar.date(
                byAdding: .day,
                value: installment.intervalDays * (nextPeriodNumber - 1),
                to: installment.startDate
            )!
            
            // 如果下一期日期已到或已过
            if nextPeriodDate <= today {
                try? generateNextPeriod(
                    installment: installment,
                    ledger: installment.account?.ledger ?? Ledger(name: "默认")
                )
            }
        }
    }
}
```

### 7.3 分期示例

```swift
// 买iPhone，分12期
let installment = try installmentService.createInstallmentPlan(
    ledger: currentLedger,
    totalAmount: 7999,
    periods: 12,
    startDate: Date(),
    account: creditCard,
    category: electronicsCategory,
    note: "iPhone 15 Pro"
)

// 系统自动：
// - 生成第1期交易（¥666.58）
// - 后续每月自动生成（通过定时任务）
// - 最后一期调整为 ¥666.63（处理余数）
```

---

## 8. 拆单与AA制

### 8.1 拆单逻辑

```swift
extension TransactionService {
    /// 创建拆单交易
    func createSplitTransaction(
        ledger: Ledger,
        totalAmount: Decimal,
        date: Date = Date(),
        fromAccount: Account,
        category: Category,
        splits: [TransactionSplit],
        note: String? = nil
    ) throws -> [Transaction] {
        // 验证拆分金额总和
        let splitTotal = splits.reduce(0) { $0 + $1.amount }
        guard splitTotal == totalAmount else {
            throw TransactionError.invalidSplitAmount
        }
        
        var transactions: [Transaction] = []
        
        for split in splits {
            let transaction: Transaction
            
            if split.isReimbursable {
                // 如果是代付，记录到应收
                let receivableAccount = try getOrCreateReceivableAccount(
                    ledger: ledger,
                    name: split.payer
                )
                
                let (expense, _) = try createReimbursableExpense(
                    ledger: ledger,
                    amount: split.amount,
                    fromAccount: fromAccount,
                    category: category,
                    reimbursementSource: split.payer,
                    note: "\(note ?? "") - \(split.payer)的部分"
                )
                transaction = expense
            } else {
                // 个人承担部分
                transaction = try createTransaction(
                    ledger: ledger,
                    type: .expense,
                    amount: split.amount,
                    date: date,
                    fromAccount: fromAccount,
                    category: category,
                    note: "\(note ?? "") - 个人部分"
                )
            }
            
            transactions.append(transaction)
        }
        
        return transactions
    }
}

struct TransactionSplit {
    let payer: String        // 承担人（"我"或朋友名字）
    let amount: Decimal      // 承担金额
    let isReimbursable: Bool // 是否需要对方还款
}

enum TransactionError: LocalizedError {
    // ...
    case invalidSplitAmount
    
    var errorDescription: String? {
        switch self {
        case .invalidSplitAmount: return "拆分金额总和与总金额不符"
        // ...
        }
    }
}
```

### 8.2 AA制示例

#### 场景：聚餐AA

```swift
// 4人聚餐，总共花了400元，我刷卡
let splits = [
    TransactionSplit(payer: "我", amount: 100, isReimbursable: false),
    TransactionSplit(payer: "张三", amount: 100, isReimbursable: true),
    TransactionSplit(payer: "李四", amount: 100, isReimbursable: true),
    TransactionSplit(payer: "王五", amount: 100, isReimbursable: true)
]

let transactions = try transactionService.createSplitTransaction(
    ledger: currentLedger,
    totalAmount: 400,
    fromAccount: creditCard,
    category: diningCategory,
    splits: splits,
    note: "聚餐"
)

// 结果：
// - 信用卡余额：-400
// - 个人餐饮支出：100（只记录自己的部分）
// - 应收-张三：+100
// - 应收-李四：+100
// - 应收-王五：+100

// 后续朋友们转账
try transactionService.receiveReimbursement(
    ledger: currentLedger,
    amount: 100,
    fromReceivableAccount: zhangSanReceivable,
    toBankAccount: bankAccount,
    note: "聚餐AA - 张三"
)
```

---

## 9. 数据统计计算

### 9.1 统计服务

```swift
@MainActor
class StatisticsService {
    private let modelContext: ModelContext
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    /// 计算时间范围内的收支统计
    func calculateIncomeExpense(
        ledger: Ledger,
        startDate: Date,
        endDate: Date
    ) -> IncomeExpenseStats {
        let transactions = ledger.transactions.filter { transaction in
            transaction.date >= startDate && transaction.date <= endDate
        }
        
        let income = transactions
            .filter { $0.type == .income }
            .reduce(0) { $0 + $1.amount }
        
        let expense = transactions
            .filter { $0.type == .expense }
            .reduce(0) { $0 + $1.amount }
        
        return IncomeExpenseStats(
            income: income,
            expense: expense,
            balance: income - expense,
            transactionCount: transactions.count
        )
    }
    
    /// 按分类统计支出
    func expenseByCategory(
        ledger: Ledger,
        startDate: Date,
        endDate: Date,
        limit: Int = 10
    ) -> [CategoryExpense] {
        // 只统计一级分类
        let parentCategories = ledger.categories.filter { 
            $0.type == .expense && $0.parent == nil
        }
        
        var results: [CategoryExpense] = []
        
        for category in parentCategories {
            // 包含子分类的所有交易
            let transactions = category.allTransactions.filter { transaction in
                transaction.type == .expense &&
                transaction.date >= startDate &&
                transaction.date <= endDate
            }
            
            let total = transactions.reduce(0) { $0 + $1.amount }
            
            if total > 0 {
                results.append(CategoryExpense(
                    category: category,
                    amount: total,
                    transactionCount: transactions.count
                ))
            }
        }
        
        // 按金额降序
        return results
            .sorted { $0.amount > $1.amount }
            .prefix(limit)
            .map { $0 }
    }
    
    /// 计算净资产趋势
    func netWorthTrend(
        ledger: Ledger,
        startDate: Date,
        endDate: Date,
        granularity: TrendGranularity = .daily
    ) -> [NetWorthPoint] {
        var points: [NetWorthPoint] = []
        let calendar = Calendar.current
        
        var currentDate = startDate
        while currentDate <= endDate {
            let netWorth = calculateNetWorth(ledger: ledger, at: currentDate)
            points.append(NetWorthPoint(date: currentDate, amount: netWorth))
            
            currentDate = calendar.date(byAdding: granularity.component, value: 1, to: currentDate)!
        }
        
        return points
    }
    
    private func calculateNetWorth(ledger: Ledger, at date: Date) -> Decimal {
        // 获取date时刻的所有账户余额
        // 简化版本：通过重放交易计算历史余额
        // 生产版本应该缓存每日余额快照
        
        let accounts = ledger.accounts.filter { !$0.excludeFromTotal && !$0.isArchived }
        return accounts.reduce(0) { $0 + $1.balance }
    }
}

struct IncomeExpenseStats {
    let income: Decimal
    let expense: Decimal
    let balance: Decimal
    let transactionCount: Int
}

struct CategoryExpense: Identifiable {
    let id = UUID()
    let category: Category
    let amount: Decimal
    let transactionCount: Int
    
    var percentage: Double = 0  // 由外部计算
}

struct NetWorthPoint: Identifiable {
    let id = UUID()
    let date: Date
    let amount: Decimal
}

enum TrendGranularity {
    case daily
    case weekly
    case monthly
    
    var component: Calendar.Component {
        switch self {
        case .daily: return .day
        case .weekly: return .weekOfYear
        case .monthly: return .month
        }
    }
}
```

---

## 10. 边界条件处理

### 10.1 常见边界情况

#### 1. 余额不足检查

```swift
extension Account {
    func canWithdraw(_ amount: Decimal) -> Bool {
        switch type {
        case .cash, .checking, .eWallet:
            return balance >= amount
            
        case .creditCard:
            guard let limit = creditLimit else { return false }
            return (limit + balance) >= amount  // 可用额度
            
        case .investment:
            return balance >= amount
            
        case .liability:
            return false  // 负债账户不能支出
            
        case .receivable:
            return false  // 应收账户不能支出
        }
    }
}
```

#### 2. 金额精度处理

```swift
extension Decimal {
    /// 确保金额最多2位小数
    var normalized: Decimal {
        return (self * 100).rounded() / 100
    }
    
    /// 格式化为货币字符串
    func formatted(currencyCode: String = "CNY") -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.currencyCode = currencyCode
        formatter.locale = Locale(identifier: "zh_CN")
        return formatter.string(from: self as NSNumber) ?? "¥0.00"
    }
}
```

#### 3. 日期边界

```swift
extension Date {
    /// 判断是否在指定日期范围内
    func isBetween(_ startDate: Date, and endDate: Date) -> Bool {
        return self >= startDate && self <= endDate
    }
    
    /// 获取月初
    var startOfMonth: Date {
        Calendar.current.date(from: Calendar.current.dateComponents([.year, .month], from: self))!
    }
    
    /// 获取月末
    var endOfMonth: Date {
        Calendar.current.date(byAdding: DateComponents(month: 1, second: -1), to: startOfMonth)!
    }
}
```

#### 4. 并发安全

```swift
// 使用Actor保证线程安全
actor AccountBalanceManager {
    private var balances: [UUID: Decimal] = [:]
    
    func updateBalance(accountId: UUID, delta: Decimal) {
        let current = balances[accountId] ?? 0
        balances[accountId] = current + delta
    }
    
    func getBalance(accountId: UUID) -> Decimal {
        return balances[accountId] ?? 0
    }
}
```

### 10.2 数据完整性检查

```swift
class DataIntegrityService {
    /// 检查账户余额是否正确
    func validateAccountBalances(ledger: Ledger) -> [String] {
        var errors: [String] = []
        
        for account in ledger.accounts {
            let calculatedBalance = calculateBalance(for: account)
            
            if abs(account.balance - calculatedBalance) > 0.01 {
                errors.append(
                    "账户\(account.name)余额不一致：记录\(account.balance)，计算\(calculatedBalance)"
                )
            }
        }
        
        return errors
    }
    
    private func calculateBalance(for account: Account) -> Decimal {
        var balance: Decimal = 0
        
        // 通过所有交易重新计算余额
        let allTransactions = account.outgoingTransactions + account.incomingTransactions
        let sortedTransactions = allTransactions.sorted { $0.date < $1.date }
        
        for transaction in sortedTransactions {
            switch transaction.type {
            case .expense:
                if transaction.fromAccount == account {
                    balance -= transaction.amount
                }
            case .income:
                if transaction.toAccount == account {
                    balance += transaction.amount
                }
            case .transfer:
                if transaction.fromAccount == account {
                    balance -= transaction.amount
                }
                if transaction.toAccount == account {
                    balance += transaction.amount
                }
            case .adjustment:
                if transaction.toAccount == account {
                    balance = transaction.amount
                }
            }
        }
        
        return balance
    }
}
```

---

## 附录：快速参考

### 交易类型决策树

```
需要创建交易？
├─ 是支出吗？
│  ├─ 是 → createTransaction(type: .expense)
│  └─ 是退款吗？
│     └─ 是 → createRefund()
├─ 是收入吗？
│  └─ 是 → createTransaction(type: .income)
├─ 是账户间转移吗？
│  ├─ 是普通转账 → createTransfer()
│  └─ 是信用卡还款 → creditCardPayment()
├─ 是报销类支出吗？
│  └─ 是 → createReimbursableExpense()
├─ 需要拆单吗？
│  └─ 是 → createSplitTransaction()
└─ 是余额调整吗？
   └─ 是 → createTransaction(type: .adjustment)
```

### 常见场景速查

| 场景 | 方法 | 核心参数 |
|-----|------|---------|
| 日常支出 | `createTransaction` | type: .expense |
| 工资到账 | `createTransaction` | type: .income |
| ATM取款 | `createTransfer` | from: 银行卡, to: 现金 |
| 信用卡还款 | `creditCardPayment` | to: 信用卡 |
| 退货退款 | `createRefund` | amount为负数 |
| 帮同事垫付 | `createReimbursableExpense` | 自动处理应收 |
| 聚餐AA | `createSplitTransaction` | splits数组 |
| 买iPhone分期 | `createInstallmentPlan` | periods: 12 |
| 余额对账 | `adjustBalance` | type: .adjustment |

---

**文档维护**: 随业务逻辑优化持续更新  
**最后更新**: 2026-01-24
